# Introdução

O Texto a seguir é um resumo de uma espeficação/documentação/arquitetura/design de uma api rest. Várias idéias e textos
foram coletados de https://docs.api.fastnotas.com/.

# Idempotência 
É a propriedade que algumas operações têm de poderem ser aplicadas várias vezes sem que o valor do resultado se altere após a aplicação inicial.

Em integrações entre sistemas é importante que o cliente informe um código próprio que identificará o recurso criado no 
sistema remoto. Um exemplo é o nosso número e número do documento nos boletos. Outro, é código de compra informado
nos WS de cartão de crédito.

O Stripe permite enviar um parâmetro no Header Http contendo o Idempotency Id. Esse Id é válido por 24 horas. Todas as requisições com o mesmo Id, nesse período de 24 horas, serão recusadas.

# GUIDs

O stripe não permite retornar uma transação por correlation id (código da venda por exemplo). Todas as requisições de entidades são feitas pelo id que o Stripe gera. Isso é um problema. Pode acontecer de uma transação de cadastro ocorrer com sucesso no Stripe e não ser possível guardar o ID deles no banco de dados. A requisição pode ser encerrada após o sucesso no stripe, o banco de dados pode falhar no momento da transação. Para contornar esse problema o Stripe permite o uso de um **Idempotence ID** para todas as requisições, vide regras da seção Idempotência.

O problema é nossa aplicação tentar realizar um cadastro, o dado ser salvo no stripe, nossa aplicação não conseguir guardar o ID e não ocorrer novas tentativas de cadastro. O stripe conterá um cadastro fantasma sem relação no o nosso BD.

Uma solução é, periodicamente, tentar sincronizar os últimos cadastros. Também é ter um campo na tabela indicando que houve uma tentativa de cadastro, quando o stripe retornasse sucesso o status seria atualizado para cadastrado_com_sucesso. Períodicamente o sistema checaria o status dessas integrações.


O formato de ids utilizado por eles é interessante. ch_asdfad234safdgasf (id de uma charge), tr_ahjfhj456465dfg (id de uma transação), cl_jkdghDFEFGDasdfadsf (id de um cliente). 

Segundo um funcionário do Stripe: They're (IDs) randomly generated by our Ruby application code. We use the ch_-style prefixes because we find it really useful to be able to immediately recognize the type of an ID when looking at logs or stacktraces.

# Cache

Cache é importante para aumentar a performance de aplicações. Nem todos os recursos podem ser cacheados. Mas, aqueles dados
que mudam pouco ou raramente mudam podem e devem ser cacheados (CEP, cidades do IBGE, 
Tipos de Dados/Categorias (Tipo de Produto, Lista de Status, Motivo de Cancelamento)).

As opções de cache, entre outras, são:
- Http-get
- HTTP Caching
- Cache do Servidor Web
- Cache na aplicação: Cache de actions do AspNet e Rails
- Varnish
- Redis
- MongoDB
- Google: redis http varnish cache


# SandBox

É importante que toda API tenha um SandBox para testes. Esse ambiente poder ser uma outra VM com menos recursos computacionais e não precisa ter todos os recursos da API implementados, ex: WebHooks. Também não precisa e não deve se comunicar com servidores remotos, ex: bancos, emails, filas, etc. 

Endereço para o sandbox: http://sandbox.minhaapi.com/

O SandBox não precisa ter https e um token de produção não deve acessar o SandBox.


# Charset

Escolher um padrão de charset ou deixar o client escolher? Acho que escolhe um padrão é a melhor opção. No caso UTF-8.

You must also pass the character set after the format, separated by a semicolon. The HTTP 1.1 specification states the default for this is ISO-8859-1, which is probably not what you want. For example, a full header for UTF8-encoded data would look like one of these:

    Content-Type: application/x-www-form-urlencoded; charset=UTF8
    Content-Type: application/json; charset=UTF8

O Charset padrão utilizado para todas as chamadas à API é o UTF-8, em caso de dúvidas consulte a RFC3629.


# Content Type

O tráfego de dados em uma API, pode utilizar os formatos FORM, JSON, XML e o PDF, dependendo do serviço consumido. Respectivamente a negociação de conteúdo deve levar em consideração o content type application/x-www-form-urlencoded para FORM, application/json para JSON e application/pdf para PDFs, tanto para entrada quanto para saída de dados. 

O Cliente deve informar o content type desejado.


# Padronização de Dados

Para o correto funcionamento do serviço alguns dados são padronizados como:

Tipo 	  | Formato  | 	Exemplo 	 | Descrição
--------|----------| -------------| -------------
Datas   | "aaaa-mm-dd" ou "aaaa-mm-ddThh:mm" | 	"2014-07-01" ou "2007-04-05T14:30" |	Todas as datas devem ser informadas seguindo esse padrão. O sistema recebe/retorna data e hora ou somente data. Padrão ISO_8601 https://en.wikipedia.org/wiki/ISO_8601 .
Valores Monetários| 	"0000.00" | "1.83","3095.72","5200459.37" | 	Todos os valores devem possuir apenas duas casas decimais, sendo assim no exemplo ao lado: "5200459.37"; que normalmente é representado como R$ 5.200.459,37, não deve conter vírgula e no lugar dela apenas um ponto representa a parte fracionária. Todos os valores, são, por padrão, considerados como valores em Real R$. 

# Retorno de Erros

Implementar


# Integrando com APIs de Terceiros

Toda requisição a APIs de terceiros de ser logada em uma tabela própria. Antes de enviar os dados, deve-se guardar (COMITAR) todos os dados enviados na tabela com status CADASTRADO. Deve-se fazer a requisição e guardar o resultado: ERRO com o erro retornado ou SUCESSO.

Como logar várias tentativas de integração e manter um registro atual? Como manter um log e um reflexo da integração?

Acho que a solução aqui é ter uma tabela genérica de logs e uma tabela específica para a entidade(endpoint). 
A solução é Comitar a tabela genérica e a tabela específica, chamar o endpoint e atualizar o BD novamente.


# Boas práticas
   - https://blog.mwaysolutions.com/2014/06/05/10-best-practices-for-better-restful-api/
   - https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api
 

 
# CURL

É uma ótima ferramenta para testar os endpoints.

    curl -D- \
       -X GET \
       -H "Authorization: Basic ZnJlZDpmcmVk" \
       -H "Content-Type: application/json" \
       "https://api.mysite.com/v1/clientes"

# Formatos de Endereço:
  - https://api.mysite.com/v1/
  - https://www.mysite.com/api/v1/
  
# Versionamento
Versionar pela URL é a boa prática. Através de custom http headers podem ocorrer problemas.
  - https://api.mysite.com/v1/
  
# Verbos HTTP
 Usar os verbos HTTP com substantivos e não verbos indicando ações:
  - Errado:
    - https://api.mysite.com/v1/cadastrarCliente
    - https://api.mysite.com/v1/alterarEnderecoDoCliente
  
  - Certo:
    - POST https://api.mysite.com/v1/clientes //no corpo enviar dados em JSON
    - PUT https://api.mysite.com/v1/clientes/1000/enderecos/10 //no corpo enviar dados em JSON
    
# Plural
Utilize o nome dos recursos no plural.
  - Errado
    - https://api.mysite.com/v1/cliente
    - https://api.mysite.com/v1/cliente/10/fatura
    
  - Certo
    - https://api.mysite.com/v1/clientes
    - https://api.mysite.com/v1/clientes/10/faturas
    
# Use sub-resources for relations
    
- GET /cars/711/drivers/ Returns a list of drivers for car 711
- GET /cars/711/drivers/4 Returns driver #4 for car 711
    
# Use HTTP headers for serialization formats

Both, client and server, need to know which format is used for the communication. The format has to be specified in the HTTP-Header.

Content-Type defines the request format.
Accept defines a list of acceptable response formats.
    
# Use HATEOAS

Hypermedia as the Engine of Application State is a principle that hypertext links should be used to create a better navigation through the API.

           {
              "id": 711,
              "manufacturer": "bmw",
              "model": "X5",
              "seats": 5,
              "drivers": [
               {
                "id": "23",
                "name": "Stefan Jauker",
                "links": [
                 {
                 "rel": "self",
                 "href": "/api/v1/drivers/23"
                }
               ]
              }
             ]
            }
    
    
# Provide filtering, sorting, field selection and paging for collections
    
## Filtering:

Use a unique query parameter for all fields or a query language for filtering.

    GET /cars?color=red Returns a list of red cars
    GET /cars?seats<=2 Returns a list of cars with a maximum of 2 seats

## Sorting:

Allow ascending and descending sorting over multiple fields.

    GET /cars?sort=-manufactorer,+model

This returns a list of cars sorted by descending manufacturers and ascending models.

## Field selection

Mobile clients display just a few attributes in a list. They don’t need all attributes of a resource. Give the API consumer the ability to choose returned fields. This will also reduce the network traffic and speed up the usage of the API.

    GET /cars?fields=manufacturer,model,id,color

## Paging

Use limit and offset. It is flexible for the user and common in leading databases. The default should be limit=20 and offset=0

    GET /cars?offset=10&limit=5

To send the total entries back to the user use the custom HTTP header: X-Total-Count.

Links to the next or previous page should be provided in the HTTP header link as well. It is important to follow this link header values instead of constructing your own URLs.
    
# Use error payloads

All exceptions should be mapped in an error payload. Here is an example how a JSON payload should look like.
    
        {
      "errors": [
       {
        "userMessage": "Sorry, the requested resource does not exist",
        "internalMessage": "No car found in the database",
        "code": 34,
        "more info": "http://dev.mwaysolutions.com/blog/api/v1/errors/12345"
       }
      ]
    } 

    
# Endpoints da API

Método  |	Endpoint |	Descrição
--------|--------| ---------------
GET |	/company 	| Retorna dados da empresa
GET |	/companies |	Retorna dados das empresas afiliadas à empresa parceira
GET |	/companies/:id |	Retorna uma empresa específica
POST |	/companies |	Cria uma empresa
DELETE |	/companies/:id |	Inativa uma empresa
PUT |	/companies/:id |	Atualiza os parâmetros de uma empresa
GET |	/customers |	Retorna todos clientes
POST |	/customers 	| Cria um cliente
POST | https://api.stripe.com/v1/charges/{CHARGE_ID}/capture | Captura uma compra
GET |	/customers/:id |	Retorna um cliente
GET | /companies/{company_id}/serviceinvoices | Listar as Notas Fiscais de Serviço (NFSE)
POST |  /companies/{company_id}/serviceinvoices | Emitir uma Nota Fiscal de Serviço (NFSE)
DELETE |  /companies/{company_id}/serviceinvoices/{id} | Cancelar uma Nota Fiscal de Serviços (NFSE)
GET  | /companies/{company_id}/serviceinvoices/{id} | Obter os detalhes de uma Nota Fiscal de Serviço (NFSE)
PUT  | /companies/{company_id}/serviceinvoices/{id}/sendemail | Enviar email para o Tomador com a Nota Fiscal de Serviço (NFSE)
GET  | /companies/{company_id}/serviceinvoices/{id}/pdf | Download do PDF da Nota Fiscal de Serviço (NFSE)
GET  | /companies/{company_id}/serviceinvoices/{id}/xml | Download do XML da Nota Fiscal de Serviço (NFSE
   
# Content-Type

Informar o content-type **Content-Type: application/json**
    
# Autenticação

  Em um sistema, seja web ou api ou mobile, um usuário terá um login e senha. É boa prática que o usuário
  consiga gerar um token para acesso a API. 
  Com esse token a autenticação é feita com HttpBasic. 
  Deve-se enviar um Header http no seguinte formato:  **Authorization: Basic ZnJlZDpmcmVk** .
  Onde, **ZnJlZDpmcmVk** é um hash base64 no formato **usuario:senha**. 
  Assim, **usuario** será o token de acesso, ex.: **api-key_ASDasfd12_3asdfRF78** e a **senha** pode ser qualquer outro valor 
  (pode ser **x**, **senha**, **pass** ), uma vez que alguns clients/mecanismos de autenticação basic podem reclamar da ausência de senha.


# Paginação

## Dados de Paginação no Header Http

  Usar parâmetros query para paginação:
  
   curl -X GET https://api.mysite.com/v1/clientes/10/telefones/?page=2&per_page=5 \
      -u 'YOUR_API_KEY:' 
     

Parâmetro | Descrição
------------ | -------------
**page:** default 1 | Implementação de uma paginação de resultados do objeto
**per_page:** Default:50 | Retorna n objetos por página

Todas as requisições de listagem retornam os dados referentes à paginação através dos seguintes headers http:

HTTP Header| 	Descrição
-----------| -----------
Current-Page| 	Página atual
Total-Pages | Total de páginas
Per-Page 	|Objetos por página

  Referência: https://docs.api.fastnotas.com/#pagina-o

## Dados de Paginação no corpo da resposta

Outra opção é retornar os dados da paginação no corpo da resposta.
Referência: https://bestbuyapis.github.io/api-documentation/#cursor-marks

      {
        "nextCursorMark": "AoNeDQhAhoq2MnByb2R1Y3RfMTE0NjYzNV91cw==",
        "total": 49911,
        "totalPages": 500,
        "queryTime": "0.037",
        "totalTime": "0.362",
        "partial": false,
        "canonicalUrl": "/v1/products(type=\"HardGood\")?show=sku,name,salePrice&pageSize=100&cursorMark=*&format=json&apiKey=YourAPIKey",
        "products": [
          {
            "sku": 5477500,
            "name": "Amazon - Fire TV Stick with Alexa Voice Remote - Black",
            "salePrice": 39.99
          },
          {
            "sku": 4397400,
            "name": "Google - Chromecast - Black",
            "salePrice": 35
          },


# WebHooks

  São eventos que acontecem dentro da api que notificam via POST uma URL pré determinada pelo cliente.
  Podem ser implementadas através de um componente de QUEUE, RabbitMQ, onde um evento é agendado/colocado na fila 
  para ser enviado/notificado na URL que o cliente informou.
  
  Uma notificação tem sucesso quando o cliente retorna o código HTTP 200. Outro código indica erro e a API
  deve ficar tentando comunicar o evento de tempos em tempos aumentando o espaço entre as requisições.
  O próprio RabbitMQ possui mecanismo de Retry.
  
  Durante a implementação da API poderão existir momentos em que você precisará aguardar alguma ação externa antes de prosseguir com seu   processo. Suponha que você necessite confirmar a emissão de uma nota fiscal antes de emitir a cobrança. Uma prática desaconselhável     seria, por exemplo, agendar uma consulta diária ao serviço de documentos do Fast Notas para verificar o status de emissao de todas as suas notas fiscais pendentes.

  Além de desperdiçar recursos de processamento, você também sofreria com o atraso entre o momento real da emissão e da consulta do webservice. Isso poderia ser resolvido diminuindo o intervalo entre as consultas, porém dependendo do número de notas fiscais pendentes, este método tornaria-se inviável em pouco tempo.

  Para resolver esse problema, inverte-se a responsabilidade da notificação: O Fast Notas avisará você quando alguma ação ocorrer. Este aviso é realizado através de um HTTP POST que o Fast Notas faz em uma URL que você pode configurar na plataforma. Estes avisos são chamados de webhooks.
  
  A Stripe tenta uma nova chamada a cada 1 hora durante 3 dias. Eles também logam a quantidade de chamadas ao endpoint, quando foi, 
  e os dados de retorno de erro/sucesso.
  
  Uma forma de implementar WebHooks é através de DomainEvents. Que são objetos que possuem os dados pertinentes ao evento: 
  data da ocorrência, nome, valor... Cada evento é representado por uma classe distinta. Os Domain Events são salvos 
  em uma única tabela juntamente com a transação atual. Um serviço pode fazer pooling na tabela e enviar esses eventos para 
  os interessados.  Pode colocar esses eventos em uma fila (RabbitMQ). 
  
  
## Tipos de Eventos
Evento |	type |	data
------| --------| --------
Documento em processamento |	document_processing |	document
Documento aguardando retorno externo |	document_waiting |	document
Documento emitido/arquivado com sucesso |	document_success |	document
Documento cancelado| 	document_canceled 	|document
Documento com erro |	document_error |	document
Documento rejeitado na emissão/arquivamento |	document_rejected |	document
Operação em processamento |	operation_processing 	|operation
Operação aguardando retorno externo 	|operation_waiting |	operation
Operação efetuada com sucesso |	operation_success |	operation
Operação com erro 	|operation_error|	operation
Operação rejeitada |	operation_rejected |	operation
Arquivo disponível | 	asset_avaliable 	| asset  
  
## Formato e método de envio
  
Todas as requisições geradas a partir de webhooks são efetuadas com o método POST, com o conteúdo no corpo (body) da requisição no formato JSON, incluindo os seguintes headers:

HTTP Header | 	Descrição
------------| ---------------
Content-Type |	application/json; charset=UTF-8
User-Agent | 	mysSiteHookshot/1.0

  A plataforma espera que sua aplicação responda com o código HTTP 2XX (200, 201, etc) em no máximo 20 segundos. Códigos de redirecionamento (3XX) não serão seguidos e serão considerados como falha.


## Retentativas

A plataforma Fast Notas irá efetuar 15 retentativas de envio caso seu sistema esteja fora do ar ou responda com um código HTTP diferente de 2xx. As retentativas são enviadas em intervalos progressivos durante aproximadamente 48 horas. Depois desse período a notificação é descartada.

## Conteúdo da requisição

Como mencionado acima, o conteúdo da requisição estará contido em seu no corpo (body), no formato JSON.
O conteúdo do atributo data irá depender do tipo de evento enviado e respeitará o mesmo formato da API REST.

      {
      "event": {
        "type": "document_processing",
        "created_at": "2017-01-19T00:58:20.835Z",
        "data": {
          "document": {
            ...
          }
        }
      }
    }


# Rate Limit

Por padrão a API do Fast Notas possui um limite de 120 requisições por minuto por empresa. Para obter o status do limite, consulte os cabeçalhos abaixo no retorno de qualquer chamada à API: Os headers abaixo

- Rate-Limit-Limit: Limite de requisições por minuto
- Rate-Limit-Remaining: Número de requisições restantes antes de atingir o limite
- Rate-Limit-Reset: Horário em que o limite será reiniciado no formato Unix Time, fuso horário UTC

Caso o limite de requisições seja atingido (Rate-Limit-Remaining igual à zero), a plataforma irá rejeitar a requisição seguinte e retornar o status HTTP status code 429 - Too Many Requests, incluindo o header Retry-After, que indica o número de segundos restantes para realizar uma nova tentativa.

O limite contempla todos os tipos de requisição, inclusive requisições inválidas do tipo HTTP status code 4xx.

Em condições normais de operação dificilmente esse limite será atingido, porém más práticas de integração podem comprometer o limite rapidamente.

## Boas práticas


### Stripe 

Before going live, test that your webhook is working properly. You can do so by sending dummy test events from the Webhooks settings pane. To do this, first enable your Dashboard's Viewing test data option, then add the endpoint to which test events should be sent. Next, click that endpoint's row to view details, and finally, click the send a test webhook button. Understand that because these are dummy, test events, they will not map to real customers, invoices, charges, or other objects in your account.

If your webhook script performs complex logic, or makes network calls, it's possible that the script would time out before Stripe sees its complete execution. For that reason, you might want to have your webhook endpoint immediately acknowledge receipt by returning a 2xx HTTP status code, and then perform the rest of its duties.

Webhook endpoints might occasionally receive the same event more than once. We advise you to guard against duplicated event receipts by making your event processing idempotent. One way of doing this is logging the events you've processed, and then not processing already-logged events. Additionally, we recommend verifying webhook signatures to confirm that received events are being sent from Stripe.

### Webhooks and API versions

The structure of an Event object sent in a webhook is dictated by the API version in your account settings at the time of the event's occurrence. For example, if your account is set to an older API version, such as 2015-02-16, and you change the API version for a specific request via versioning, the Event object generated and sent to your endpoint is still based upon the 2015-02-16 API version.

Event objects can never be changed once created. For example, if a charge is updated, the original charge event remains unchanged. This means that subsequent updates to your account's API version do not retroactively alter existing Event objects. Fetching older events by calling /v1/events using a newer API version also has no impact on the structure of the received events.

You can set test webhook endpoints to either your API version in use or the most current API version. The Event sent to the webhook URL is structured for the endpoint's specified version. You can use endpoint versioning to test the latest API version before upgrading to it.



### Evite polling

Polling é o nome do procedimento usado para buscar o status de determinada informação em intervalos de tempo consecutivos. Sabemos que é comum implementar rotinas diárias de consulta de status. Enquanto este procedimento funciona satisfatoriamente com um número baixo de registros, você poderá ultrapassar o limite de requisições caso o número de consultas aumente.

É justamente por isso que a plataforma Fast Notas oferece os webhooks. Em vez de gastar recursos computacionais com polling, configure a plataforma Fast Notas para avisar seu backend via POST imediatamente quando um evento ocorrer. Com isso você não desperdiça recursos e garante que sua plataforma estará com os dados sempre atualizados. Se você precisar de um tipo de webhook que ainda não esteja disponível, converse com nossa equipe e ficaremos felizes em criar um novo tipo de disparo que ajude você a se manter dentro do limite de requisições.

### Use cache

Recursos que não são atualizados frequentemente podem ser armazenados em cache localmente. Por exemplo, em vez de efetuar uma requisição de listagem de documentos toda vez que um cliente quiser visualizar o status da sua nota fiscal, faça uma única consulta à API e armazene o resultado, configurando o tempo de expiração que julgar necessário. Soluções baseadas em memcache ou Redis funcionam muito bem nesses casos.


# HTTP status codes

A API segue o padrão que usa códigos de resposta HTTP convencionais para indicar o sucesso ou fracasso de uma solicitação da API. Em geral, os códigos na gama 2xx indicam sucesso, os códigos na gama 4xx indicam um erro dada a informação fornecida (por exemplo, um parâmetro necessário foi omitido, ou informado com um valor errado, etc) e os códigos na gama indicam um 5xx de erro com os servidores da lista (esses são raros).



Código |	Significado
-------|-------------
200 - OK |	Request realizado com sucesso
201 - Created |	Cadastro criado com sucesso
204 - No Content |	Requisição sem conteúdo
400 - Bad Request |	Erro de sintaxe JSON no corpo do request
404 - Not Found |	Registro não encontrado
422 - Unprocessable Entity |	Parâmetros inválidos. Verificar erro na resposta
429 - Too Many Requests |	Limite de requisições excedido
500 - Internal Server Error |	Erro interno do servidor

# Consumindo APIS
 Em caso de a API retonar um código diferente de 200, um erro, pode-se lançar uma exceção ou retornar um erro com um objeto ApiResponse.
 Acho que lançar uma exeção não é uma opção válida. É a pior opção, pois interrompe o fluxo prematuramente. 
 Em um loop teria que colocar um trycatch...
 
 Clients de APIs não devem lançar exceções quando um Status Code diferente de 200 for retornado.
 
 Exemplo de um bom client de API:
 
      APIResult<Pessoa> RetornarPessoa(string codigoPessoa)
      {
         ...
      }
      
      var result = RetornarPessoa("123")
      if(result.Erro)
      {
         ///trata o erro
      }
      
      var pessoa = result.Data;
      
      ---------------------------------------------------------------------------------------
      
      public class APIResult<T> // T pode ser uma classe Pessoa ou um List<Pessoa>
      {
         public T Result {get; protected set;}
         public bool Sucesso {get; protected set;}
         public bool Erro {get; protected set;}
         
         ///Paginação
         public int PaginaAtual {get; protected set;}
         public int TotalDePaginas {get; protected set;}
         public int ItensPorPagina {get; protected set;}
      
      }
   

  
# Ferramentas de Documentação de API
   - https://swagger.io/
   - https://github.com/lord/slate
    
    
# Exemplos de APIs

  - https://boleto.cloud/app/dev/api
  - https://api.boletosimples.com.br/
  - https://documentation.mailgun.com/en/latest/api_reference.html
  - https://docs.api.fastnotas.com/
  - https://api.nfe.io/sandbox/index
  - https://stripe.com/docs/api
  - https://bestbuyapis.github.io/api-documentation/
  - https://developers.cimediacloud.com/
  - http://dev.enchant.com/api/v1
  
    
    
  
